/* * Created on May 20, 2005 * Created by wooo as part of TCS */package clad;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;import java.util.HashSet;import java.util.Hashtable;import java.util.Iterator;//import javax.naming.ldap.HasControls;/*** @author wooo * */	public class Mapper {			/**	* This method returns an array of Path objects representing all linear paths between nodes of the graph (ie all maximum length paths with no multifurcations) 	 * 	 */	    public static Path[] getPaths(ArrayList edges,boolean gapmode) {        Path [] paths = new Path[0];        ArrayList pathlist = new ArrayList();        Iterator i = edges.iterator();        LWEdge prev = null;        while (i.hasNext()) {            LWEdge edge = (LWEdge)i.next();            ArrayList pathedges = new ArrayList();            TaxaItem source = edge.source;      	    TaxaItem dest = edge.dest;      	    if (source == null || dest == null) {      	        System.err.println("source or dest == null");      	    }      	    int numNbors = source.nbor.size();      	    Path path = new Path(null,null,-1);      	          	    if (numNbors > 2 || !source.isIntermediate) {      	        if (source.isIntermediate) {      	            path.dest = source;      	        } else {      	            path.source = source;      	        }      	    } else {      	        System.err.println("there is a problem, source is not the end, try dest?");      	    }      	    // now that we have the first end, go through the rest until we have the path end      	    prev = edge;      	    while(dest.nbor.size() <= 2 && dest.isIntermediate) {      	        edge.path = path;				//      	        System.out.println("edge.path(" + edge + ") assigned to path:" +path);      	        pathedges.add(edge); // add									 //      	        source.paths.add(path);    									 //      	        dest.paths.add(path);      	        edge.source.paths.add(path);          	    edge.dest.paths.add(path);      	              	        edge = (LWEdge)i.next();      	        source = edge.source;      	        dest = edge.dest;				      	        prev = edge;      	    }      	    // now dest is the other end...      	    int type = -1;      	    edge.path = path;			//      	    System.out.println("edge.path(" + edge + ") assigned to path:" +path);      	          	    pathedges.add(edge);      	    edge.source.paths.add(path);      	    edge.dest.paths.add(path);      	    if (!dest.isIntermediate) { // second is a HAP      	        if (path.source == null) { // first was an internal      	            type = LWEdge.HAPINT;      	            path.source = dest;      	        } else { // first was a HAP      	            type = LWEdge.HAPHAP;      	            //      	          path.source = path.dest;      	            path.dest = dest;      	            // set the diffferences and sites for this path                    // mark this path as resolved      	            computeDifferences(path, gapmode);					path.resolved = true;      	                  	        }      	    } else{ // second is internal      	        if (path.source == null) { // first was an internal      	            path.source = path.dest;      	            path.dest = dest;      	            type = LWEdge.INTINT;      	        } else { // first was a HAP      	            path.dest = dest;      	            //path.source = dest;      	            type = LWEdge.HAPINT;      	        }      	    }      	          	    path.edges = pathedges;      	    path.type = type;      	    pathlist.add(path);      	    /*source.paths.add(path); // keep track of all paths that end at a given taxaitem				dest.paths.add(path);*/			            prev = edge;        }        paths = (Path[])pathlist.toArray(paths);        return paths;    }	/**	* Computes the array of differences (an Integer array, each int representing the site number of the differenc) between the two ends of path	 * @param path	 */    private static void computeDifferences(Path path, boolean gapmode) {/*		if (label.equals("Gaps = 5th state")) {			gapmode = true;		} else if (label.equals("Gaps = missing")) {			gapmode = false;		}*/		        TaxaItem source = path.source;        TaxaItem dest = path.dest;        for (int siteNum = 0; siteNum < source.characters.length; siteNum++) {            if (source.characters[siteNum] != '?' && dest.characters[siteNum] != '?' &&				source.characters[siteNum] != dest.characters[siteNum]) { //FIXME NOTE only checking for ?, not checking case, etc.				if (!gapmode) {					// treat gaps as missing					if (source.characters[siteNum] == '-' || dest.characters[siteNum] == '-') // if one is a gap char, get out of here!						continue;				} // otherwise treat gaps as fifth state, so it doesn't matter if it's a gap or not, it is a difference...								path.differences.add(new Integer(siteNum));            }        }    }    /**	* Returns a two element array of TaxaItem objects, the first element is the unresolved end and the second is the resolved end	 * returns null if neither end of the path is resolved      * @param path     * @return array of TaxaItems (length 2) or null     */    private static TaxaItem []isExternalPath(Path path) {        		if (path.source.resolved) {			return new TaxaItem [] {path.dest,path.source};		} else {			if (path.dest.resolved) {				return new TaxaItem [] {path.source,path.dest};			}		}		return null;    }    /**	* Given the list of all edges in the graph, and the maxParsimonyDistance, map back all the character changes to branches in the network	 * There are several things to note:	 *	Ambiguities 	 *	not dealing with iupac or gaps/missing data correctly probably?	 *		 *   	 * @param myEdges an arraylist of all edges in the network	 * @param maxParsimonyDistance, the calculated or specified maximum of steps for parsimony     */    public static void map(ArrayList myEdges, int maxParsimonyDistance, boolean gapmode) {						        Path[] paths = Mapper.getPaths(myEdges,gapmode);		// sort paths, I guess, shorter first...		PathCompare pc = new PathCompare();				Arrays.sort(paths, pc ); // sort the paths by type (haphap, hapint, intint)		Arrays.sort(paths, new PathCompare2() ); // now sort within the above classes by length		        // go through and resolve all the haphap edges done already        // for hapint paths, get all differences between this hap and the haps in other hapint paths,         // that are shared in all paths (but don't consider paths where the hap is more than the pars limit away?)                // if this number of shared differences to this path == the length of the path, just assign the int to:        // hap's seq for all nucs not in the unique differences, and the differences		int numUnresolvedPaths = 0;        boolean changed = false;		int resolverCount = 2;		boolean secondtry = false;		int lastNumUnresolvedPaths = 0;		do { // do while (resolverCount <= maxParsimonyDistance && numUnresolvedPaths != 0)			do { // do while secondtry == true				do { // do while changed == true					numUnresolvedPaths = 0;					//System.out.println("starting a loop");					changed = false;										for (int path = 0; path < paths.length; path++) { // go through all the paths						//System.out.println("path " + paths[path] );						if (paths[path].resolved) { // skip resolved paths							// just ignore this (already resoloved...)							// System.out.println("resolved path " + paths[path] );						} else { // if this path isn't resolved yet...							numUnresolvedPaths ++;							//System.out.println("unresolved path " + paths[path] );							// could be that both ends are resolved now...							if (paths[path].source.resolved && paths[path].dest.resolved) { // if both ends are resolved								// System.out.println("resolving: " + paths[path]);								computeDifferences(paths[path], gapmode);								secondtry = false;								//(after assigning the mutations at the loose end and marking it as resolved)								paths[path].resolved = true;																numUnresolvedPaths --;								changed = true;							} else { //  if both ends are not yet resolved								TaxaItem [] ends = isExternalPath(paths[path]); // returns loose end first																if (ends != null) {									Hashtable seqs = new Hashtable();									// System.out.println("external path " + paths[path] );									// try to resolve each of these paths...									//get all paths from the unresolved end of this, to a resolved node									HashSet pathset = new HashSet();									pathset.add(paths[path]);									HashSet resolvednodeset = new HashSet();									HashSet siteset = null;									ArrayList endPaths = new ArrayList();																		getResolvedNodes(ends[0],pathset, resolvednodeset, endPaths);																		// System.out.println("found " + resolvednodeset.size() + " nodes in " + pathset.size() + " paths");									// compare the resolved end to each node in resolvednodeset									TaxaItem node = null;									// any that exist between all resolvednodes (we could impose a parsimony limit?) should be be mapped to this path									Iterator it = resolvednodeset.iterator();									boolean first = true;									while (it.hasNext()) {										node = (TaxaItem)it.next();																				Path temppath = new Path(node,ends[1],-1);										computeDifferences(temppath, gapmode);										if (first) {											siteset = new HashSet(temppath.differences);											first = false;										} else {											siteset.retainAll(temppath.differences); //FIXME these are assuming that any change at all is good... what if a site changes to two different things (on two branches?)										}										// for this node										// for each difference (in siteset), if the value of that site is not in the hashtable										Iterator siteIt = siteset.iterator();										while (siteIt.hasNext()) {											// create a new character array of length numsites											Integer site = (Integer)siteIt.next();											Character ch = new Character(node.characters[site.intValue()]);											if (!seqs.containsKey(ch)){												seqs.put(ch, new Integer[node.characters.length]);												// then, add to the appropriate char array and site + 1																							}											Integer [] counts = (Integer[])seqs.get(ch);											counts[site.intValue()] = (counts[site.intValue()] == null)?(new Integer(1)):(new Integer(counts[site.intValue()].intValue()+1));										}									}									// if number fixed == the length of this path, mark it as resolved									//System.out.println("siteset = " + siteset.size() + " and it has " + paths[path].edges.size() +  " shared among " + resolvednodeset.size()+ " resolved nodes");									if (siteset.size() == paths[path].edges.size()) { // FIXME if not all paths are resolved at this level, we could make another pass through and do those with numdiff != num branches?										boolean resolved = checkCons(siteset, seqs, paths[path], ends, resolvednodeset.size(), secondtry);																				if (resolved) {											secondtry = false;											numUnresolvedPaths--;											changed = true;										}									} //end if the number of sites matched exactly the length of this path									else {																				if (siteset.size() < paths[path].edges.size() && secondtry) {											// we have less sites than mutations...											// find the nearest resolved end (from the loose end)											TaxaItem closestNode = null;											closestNode = getNearestResolvedNode(paths[path], ends[0]);											if (closestNode != null) {												Path pigidy = new Path(ends[1], closestNode, -1);												computeDifferences(pigidy, gapmode);												// get a good set of differences (siteset.size == paths[path].edges.size												HashSet hs = new HashSet(pigidy.differences);																								hs.removeAll(siteset);												//System.out.println("siteset (after adding some)= " + siteset.size() + " and it has " + paths[path].edges.size() +  " shared among " + resolvednodeset.size()+ " resolved nodes");												if (hs.size() + siteset.size() >= paths[path].edges.size()) {													Iterator sites = hs.iterator();													// fill cons here too?													while (siteset.size() < paths[path].edges.size()) {														siteset.add(sites.next()); // add some more sites!													}												}												boolean resolved = checkCons(siteset, seqs, paths[path], ends, resolvednodeset.size(), secondtry);												//System.out.println("resolved = " +resolved);												if (resolved) {													secondtry = false;													numUnresolvedPaths--;													changed = true;												}												continue;											}																						// compute the differences between the two											// add however many more differences to siteset to make it equal											// resolve it with those!											// FIXME if there are no nearest neighbors, or if it is one branch? then?																						// break;																																}										// THIS works for most, but not all!										// how about finding sites that only occur in paths to a given node? 										// if this number == the number of branches on that node's path										// voila!																														// maybe only do this on a second try?										// FOR NOW I THINK I CAN RESOLVE THIS IN THE ABOVE CONSENSUS STUFF, POSSIBLE?										// can we place the extra sites on all other paths (check all paths from the resolvednodeset)										// let n be the number of extra sites										// get the resolvednodesset for each path in resolvednodeset that comes back toward this node...										// how do we know which path in the node?  these paths are in ArrayList endPaths!										Iterator eachpath = endPaths.iterator();										boolean first3 = true;										HashSet siteset2 = null;										HashSet allOtherSites = new HashSet();										while (eachpath.hasNext()) {											Path curpath = (Path)eachpath.next();											// System.out.println("path="+curpath);											TaxaItem [] ends2 = isExternalPath(curpath); // returns loose end first											if (ends2 != null) {												// System.out.println("external path " + paths[path] );												// try to resolve each of these paths...												//get all paths from the unresolved end of this, to a resolved node												HashSet resolvednodeset2 = new HashSet(resolvednodeset);												// now remove the end from curpath.whicheverisresolved												resolvednodeset2.remove(ends2[1]);												// and add the end from the original path.whicheverisresolved...												resolvednodeset2.add(ends[1]);												// System.out.println("found " + resolvednodeset.size() + " nodes in " + pathset.size() + " paths");												// compare the resolved end to each node in resolvednodeset												TaxaItem node2 = null;												// any that exist between all resolvednodes (we could impose a parsimony limit?) should be be mapped to this path												Iterator it2 = resolvednodeset2.iterator();												// System.out.println("there are " + resolvednodeset2.size() + " nodes to check!");												// boolean first2 = true;												while (it2.hasNext()) {													node2 = (TaxaItem)it2.next();													Path temppath = new Path(node2,ends2[1],-1);													computeDifferences(temppath, gapmode);													// System.out.println("ends=" +ends[0] + " " + ends[1]);													if (node2 != ends[1] && ends2[1] != ends[1]) {														allOtherSites.addAll(temppath.differences);														// System.out.println(temppath);													}													if (first3) {														siteset2 = new HashSet(temppath.differences);														first3 = false;													} else {														siteset2.retainAll(temppath.differences); 													}												}												// siteset2 is now the list of all sites for this current one...											} else {												System.err.println("ends2 == null?  This is bad!");											}										}										HashSet diff = new HashSet(siteset);										// System.out.println("removing (potentially) " + siteset2.size() + " of " + siteset.size());										diff.removeAll(siteset2); // diff now has all sites not found in all other paths										//System.out.println("first diff siteset = " + diff.size() + " and it has " + paths[path].edges.size() +  " shared among " + resolvednodeset.size()+ " resolved nodes");										if (diff.size() == paths[path].edges.size()) {											boolean resolved = checkCons(diff, seqs, paths[path], ends, resolvednodeset.size(), secondtry);											if (resolved) {												// System.out.println("first attempt!");																								secondtry = false;												numUnresolvedPaths--;												// System.err.println("resolving");												changed = true;												//FIXME don't I need to mark the path as resolved, and the two end too?												break;											}										} else {											diff = new HashSet(siteset);											diff.removeAll(allOtherSites); // diff now has all sites found in no other paths										   //System.out.println("second diff siteset = " + diff.size() + " and it has " + paths[path].edges.size() +  " shared among " + resolvednodeset.size()+ " resolved nodes");											if (diff.size() == paths[path].edges.size()) {												boolean resolved = checkCons(diff, seqs, paths[path], ends, resolvednodeset.size(),secondtry); //FIXME												if (resolved) {													// System.out.println("second attempt!");																										secondtry = false;																										numUnresolvedPaths--;													// System.err.println("resolving");													changed = true;													//FIXME don't I need to mark the path as resolved, and the two end too?													break;												}											}											//System.out.println("diffsize != number of branches: " + diff.size()+ " != " + paths[path].edges.size());										}										//If we reach here, and it is a 2nd attempt										// and there is 1 edge and 2 differences										// lets assign one, label it as both, and see what happens...										//	System.out.println("secondtry == " + secondtry);										if (secondtry) { //FIXME I am currently adding all the extras to this branch!!											if (siteset.size() >= paths[path].edges.size()+1 && siteset.size() == resolverCount) {																								secondtry = false;																								//	add both (or all) possible ones (for a record) 												//  then, for the ones that have a mutation, assign it a change from itself to the value of another branch that has this site in its path! (the closest one?)												//	or better yet, a path that has one edge resolved and the unresolved node is the same as this path's unresolved node!																								// System.out.println("there are " + siteset.size()+ " sites and " + paths[path].edges.size() + " branches");												// System.out.println("resolving path: " + paths[path].source + " to " + paths[path].dest);												paths[path].resolved = true; //FIXME, adds too many to other branches!  need to either do less, or start at 1 and move up?												ends[0].isAmbiguous = true;												numUnresolvedPaths--;												changed = true;												paths[path].differences = new ArrayList(siteset);																																				// Iterator i2 = resolvednodeset.iterator();												// find another half resolved path from ends[0] (not including this one)												// Path cpath = null;												TaxaItem resolvedEnd = null;																								resolvedEnd = getNearestResolvedNode(paths[path], ends[0]);																								if (resolvedEnd != null) {													Hashtable cons = new Hashtable();													Iterator i = siteset.iterator();													// cpath is a half resolved path connecting directly to the unresolved end of the current path													// for each site that we are assigning to this path (officially) change it to the value of cpaths's resolved end (if it is different!)													for (int sitenum = 0; sitenum < paths[path].edges.size(); sitenum++) {														Integer site = (Integer)i.next();														if (ends[1].characters[site.intValue()] != resolvedEnd.characters[site.intValue()]) {															Character c = new Character(resolvedEnd.characters[site.intValue()]);															cons.put(site,c); // just pick a site from one of the paths															// System.out.println("my second try is making a change! setting site " + site + " to " + c);														} else {															System.out.println("site " + site + "was not different!");														}																											}																										assignSequence(ends,paths[path],cons);													break;												}											} 										}									}								}		                    							}						} // end else (path is unresolved)					} // end for all paths 				} while (changed);				//System.out.println("there are " + numUnresolvedPaths + " unresolved paths!");				//FIXME may want to go through now and use less discriminating measures to resolve things?								if (numUnresolvedPaths > 0 && (lastNumUnresolvedPaths != numUnresolvedPaths)) {					secondtry = true;					resolverCount = 2;					lastNumUnresolvedPaths = numUnresolvedPaths;				} else {					if (lastNumUnresolvedPaths == numUnresolvedPaths)						secondtry = false; // leave				}			} while (secondtry);			resolverCount++;			//System.out.println("resolver count = " + (resolverCount-1));			secondtry = true;		} while (resolverCount <= maxParsimonyDistance && numUnresolvedPaths != 0);		System.out.println("there are " + numUnresolvedPaths + " unresolved paths!");    }			private static TaxaItem getNearestResolvedNode(Path path, TaxaItem end) {		Path cpath = null;		TaxaItem resolvedEnd = null;		// rather than just getting the first, now we are looking for one that is a real seq...		for (int pathnum = 0; pathnum < end.paths.size(); pathnum++) {			cpath = (Path)end.paths.get(pathnum);			if (cpath != path) {				if (cpath.source.resolved) {					// found a half resolved path from the unresolved end of this!					if (resolvedEnd == null)						resolvedEnd = cpath.source;					else 						if (!resolvedEnd.isIntermediate)							resolvedEnd = cpath.source;					//										break;				} else 					if (cpath.dest.resolved) {						if (resolvedEnd == null)							resolvedEnd = cpath.dest;						else 							if (!resolvedEnd.isIntermediate)								resolvedEnd = cpath.dest;					}			}		}		return resolvedEnd;	}		private static boolean checkCons(HashSet sites, Hashtable seqs, Path path, TaxaItem [] ends, int resolvedNodeSetSize, boolean secondtry) {		// FIXME  do we want to check for same chars too?		boolean result = false;		Iterator eachsite = sites.iterator();		Hashtable cons = new Hashtable();				while (eachsite.hasNext()) {			Integer site = (Integer)eachsite.next();			Iterator eachChar = seqs.keySet().iterator();						while (eachChar.hasNext()) {				Character ch = (Character)eachChar.next();				Integer [] counts = (Integer[])seqs.get(ch);				if (counts[site.intValue()] != null && counts[site.intValue()].intValue() == resolvedNodeSetSize) {					// this site is always this char, so use it for sure!					cons.put(site,ch); // hash on the site and its value is the char				}			}		}		// otherwise, lets hold off for a bit...		if (cons.size() == sites.size()) { // if we have a perfect agreement of all sites and the right number...			path.resolved = true;			result = true;			path.differences = new ArrayList(cons.keySet());			// changed = true;			// find the best consensus for node used to assign the seq.			assignSequence(ends,path,cons);			// currently uses the consensus, and requires a complete consensus!		} else { // we don't have agreement in the consensus of the other sites			if (secondtry) {				// System.out.println("there is not complete consensus at all sites, but since it is a second try, we'll do our best!");				// System.out.println("path=" + path);				// System.out.println("cons has " + cons.size() + " and sites has " + sites.size());				// find the closest resolved node and assign the unresolved consensi to it's value?				// FIXME keep track of how we made a guess?								Path cpath = null;				TaxaItem resolvedEnd = getNearestResolvedNode(path, ends[0]);								if (resolvedEnd != null) {					HashSet remain = new HashSet(sites);					remain.removeAll(cons.keySet());															Iterator i = remain.iterator();					// cpath is a half resolved path connecting directly to the unresolved end of the current path					// for each site that we are assigning to this path (officially) change it to the value of cpaths's resolved end (if it is different!)					while (i.hasNext()) {						// for (int sitenum = 0; sitenum < paths[path].edges.size(); sitenum++) {						Integer site = (Integer)i.next();						if (ends[1].characters[site.intValue()] != resolvedEnd.characters[site.intValue()]) {							Character c = new Character(resolvedEnd.characters[site.intValue()]);							cons.put(site,c); // just pick a site from one of the paths							//System.out.println("my second try is making a change! setting site " + site + " to " + c);						} else {							System.out.println("site " + site + "was not different doh!");						}					}										if (cons.size() == sites.size()) { // FIXME need some way to say this was ambiguous!						path.resolved = true;						ends[0].isAmbiguous = true; // mark the resolved end as ambiguous						path.isAmbiguous = true;						result = true;												path.differences = new ArrayList(cons.keySet());						assignSequence(ends,path,cons);					}				}			}			}		return result;		}    /**	* @param myEnds     * @param myPath     * @param myNode     */    private static void assignSequence(TaxaItem[] myEnds, Path myPath, Hashtable cons) {        myEnds[0].characters = (char[])myEnds[1].characters.clone();        myEnds[0].resolved = true;		if (myEnds[1].isAmbiguous) { // if we are resolving off of a node that is ambiguous, we must propogate the ambiguity			myEnds[0].isAmbiguous = true;		}        Iterator it = cons.keySet().iterator();        while(it.hasNext()) {            Integer site = (Integer)it.next();            myEnds[0].characters[site.intValue()] = ((Character)cons.get(site)).charValue();			        }    }    /**	* @param myPath     * @param myPathset     * @param myResolvednodeset     * @return     */    private static void getResolvedNodes(TaxaItem loosend, HashSet myPathset, HashSet myResolvednodeset, ArrayList endPaths) {        // for each path in loosend.paths                Iterator it = loosend.paths.iterator();        while(it.hasNext()) {            Path path = (Path)it.next();                        if (!myPathset.contains(path)) { // if the path is in myPathset, skip it                myPathset.add(path);                //  if not, look at the source and dest:                // 	  if either is resolved, add it to myResolvednodeset                if (path.source.resolved) {                    myResolvednodeset.add(path.source);					endPaths.add(path);                } else {                    getResolvedNodes(path.source, myPathset, myResolvednodeset, endPaths);                 }				                if (path.dest.resolved) {                    myResolvednodeset.add(path.dest);					endPaths.add(path);                } else {                    getResolvedNodes(path.dest, myPathset, myResolvednodeset, endPaths);                }            }        }                        //    if not, call getResolvedNodes(thatend, myPathset, myResolvednodeset) on both ends        //  return         return;    } 		}